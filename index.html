<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Re-Enter Regular Expressions</title>
<!-- metadata -->
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>


</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1>Re-Enter Regular Expressions</h1>
</div>

</div>


<div class="presentation">

<div class="slide">
  <center>
  <h1 style="font-size: 300%">Re-Enter Regular Expressions</h1>
  <br>
  <h2>Doug Hoyte</h2>
  </center>
</div>



<div class="slide">
  <h1>Regexp::Debugger</h1>
  <ul>
    <li>What is the regexp engine actually doing? Use <b>rxrx</b></li>
    <li>Which parts of the regexp and input data are most expensive?</li>
    <li><i>Demo:</i> match <pre>/[ab]{5}bbb/</pre><br>Against <pre>'aaaaaaaaaaaaaaaaQQQQQQQQQaaaaaaaaaaaaaaaQQQQQQQQQQQQ'</pre><br> Press 'h' in the debugger to generate heat-maps</li>
  </ul>
</div>



<div class="slide">
  <h1>Regexp::Assemble - Demo</h1>
  <ul>
    <li>Assembles multiple regexps into a single regexp as a trie data-structure</li>

    <li>To search for the following sequences<pre>
TTGATG  TTGGAC  TTCAAG  TTCAAC
    </pre></li>
    <li>The obvious regular expression is<pre>
(TTGATG|TTGGAC|TTCAAG|TTCAAC)
    </pre></li>
    <li>This is what Regexp::Assemble compiles<pre>
TT(G(ATG|GAC)|CAA[CG])
    </pre></li>
    <li><i>Demo</i></i>
  </ul>
</div>



<div class="slide">
  <h1>Regexp::Assemble - Implementation</h1>
  <ul>
    <li>But how do we know which sub-expression matched?</li>
    <li>One of the ways perl's engine is special is that it can run perl code during the match</li>
    <li>Regexp::Assemble uses the <b>(?{ ... })</b> regexp directive:<pre>
TT(G(ATG(?{2})|GAC(?{3}))|CAA(C(?{0})|G(?{1})))
    </pre></li>
    <li>After a successful match the index of the matching sub-expression will be stored in <b>$^R</b> (aka <b>$LAST_REGEXP_CODE_RESULT</b>)
    <li>Although here we're just returning integers, this could be arbitrary perl code</li>
  </ul>
</div>



<div class="slide">
  <h1>Regexp::Grammars</h1>
  <ul>
    <li>Adds recursive descent parsing to perl's regexp engine</li>
    <li>Affects regexps defined lexically:
      <pre>
        {
          use Regexp::Grammars;

          ## regexps here will support grammars
        }
      </pre>
    </li>
  </ul>
</div>

<div class="slide">
  <h1>Regexp::Grammars - Parse email addresses</h1>
  <ul>
    <li>You know how you should never use a regexp to match an email address? Well now you can...</li>
    <li>Abridged version of Tom Christiansen's RFC5322 parser:</li>
  </ul>
  <pre style="font-size: 75%">
    my $rfc5322 = qr{
      # Match this...
      &lt;address&gt

      # As defined by these...
      &lt;token: address&gt         &lt;mailbox> | &lt;group>
      &lt;token: mailbox&gt         &lt;name_addr> | &lt;addr_spec>
      &lt;token: name_addr&gt       &lt;display_name>? &lt;angle_addr>
      &lt;token: angle_addr&gt      &lt;CFWS>? \&lt; &lt;addr_spec> \> &lt;CFWS>?
      &lt;token: display_name&gt    &lt;phrase>
      &lt;token: mailbox_list&gt    &lt;[mailbox]> ** (,)
      &lt;token: addr_spec&gt       &lt;local_part> \@ &lt;domain>
      ...
    }x;
  </pre>
</div>



<div class="slide">
  <h1>Regexp::Grammars - Demo</h1>
  <ul>
    <li>Nested parentheses are the classic example of something you can't do with a regexp</li>
    <li><i>Demo:</i> <b>arith2lisp.pl</b> is a program that parses infix arithmetic expressions and converts them into lisp-style prefix expressions</li>
  <ul>
</div>



<div class="slide">
  <h1>Regexp::Exhaustive</h1>
  <ul>
    <li>When you want to find all the occurrences of a regular expression in a string you can use <b>m//g</b> in perl ("findall" in python/javascript):
  <pre>
    @matches = "AAAA" =~ m/AA/g;
  </pre></li>
    <li>These are the matches it returns: <pre>
    AAAA
    --
      --
    </pre></li>
    <li>But what if you want all the possible matches? <pre>
    AAAA
    --
     --
      --
    </pre></li>
  <ul>
</div>

<div class="slide">
  <h1>Regexp::Exhaustive - Implementation</h1>
  <ul>
    <li>Regexp::Exhaustive does this by inserting code that records a successful match and then artificially failing the match in order to invoke back-tracking</li>
    <li>The <b>m/AA/g</b> regexp would be transformed into: <pre>
    AA(?{ record_match(); })(*FAIL)
    <pre></li>
    <li>Here is how to get all sub-strings from a string: <pre>
      say for exhaustive('abc' => qr/.+/);
      # abc
      # ab
      # a
      # bc
      # b
      # c
    </pre></li>
  </ul>
</div>


<div class="slide">
  <h1>Regexp::Exhaustive - Factorisation</h1>

  <ul>
    <li>Crazy method to determine if an integer is prime invented by ABIGAIL:<br><br>
<pre>
sub is_prime {

  !( (1 x shift) =~ /^(..+)\1+$/ )

}
</pre>
    </li>
    <li>With Regexp::Exhaustive you can find all divisors:<br><br>
<pre>
sub divisors {

  map length, exhaustive((1 x shift) =>
                         qr/^(.+?)\1*$/)

}
</pre>
    </li>
  </ul>
</div>



<div class="slide">
  <h1>Bio::Regexp</h1>
  <ul>
    <li>Specialised regexp language for biological data like DNA, RNA, and protein sequences</li>
    <li>Exhaustive search, even for double-stranded and circular molecules</li>
  </ul>
  <center><img height="75%" width="75%" src="img/frames.svg"></center>
</div>



<div class="slide">
  <h1>Bio::Regexp - IUPAC codes</h1>
  <ul>
    <li>Supports IUPAC abbreviations, which are the same idea as regexp character classes</li>
    <li>Regexp character class: <b>\w</b> is short for <b>[a-zA-Z0-9_]</b></li>
    <li>IUPAC abbreviation: <b>Y</b> is short for <b>[CT]</b></li>
    <li>If you buy PCR primers and specify <b>Y</b> in the sequence, for that position 50% of the molecules will bind to a <b>C</b> and 50% to <b>T</b></li>
  </ul>
</div>




<div class="slide">
  <h1>Bio::Regexp - Single pass scans</h1>
  <ul>
    <li>Because DNA is a double-helix and one strand corresponds to the other strand letter-by-letter, we also need to scan the <b>reverse complement</b> strand</li>
    <li>Bio::Regexp can scan for your pattern(s) on the main strand and the reverse complement strand in a single pass so you don't have to copy and reverse the strand (also improves memory locality)</li>
  </ul>
  <center><img height="90%" width="90%" src="img/revcomp-search.svg"></center>
</div>



<div class="slide">
  <h1>Bio::Regexp - Circular inputs</h1>
  <ul>
    <li>Normally no input data is copied at all except for circular molecules</li>
    <li>With circular molecules, we only need to copy this amount to see if any matches span the arbitrary location chosen to be the "start"/"end"</li>
  </ul>
  <img height="90%" width="90%" src="img/circular-copying.svg">
</div>



<div class="slide">
  <h1>Unicode Properties</h1>

The greek alphabet doesn't round-trip through case conversions (final sigma form is lost):

<pre style="margin-left: 100px">
$ perl -CAS -E 'use utf8; say lc(uc("ŒòŒ∑œÉŒ≠Œ±œÇ"))'
Œ∏Œ∑œÉŒ≠Œ±œÉ
</pre>

But we can use a simple regexp to correct this:

<pre style="margin-left: 100px">
sub greekify { $_[0] =~ s/(?<=\p{Greek})œÉ\b/œÇ/gr }
</pre>

This puts back the final sigma form in greek text:

<pre style="margin-left: 100px">
greekify(lc(uc("ŒòŒ∑œÉŒ≠Œ±œÇ")))
=> ŒòŒ∑œÉŒ≠Œ±œÇ
</pre>

Without breaking other uses of sigma:

<pre style="margin-left: 100px">
greekify(lc(uc("The sample is 5œÉ from the mean")))
the sample is 5œÉ from the mean
</pre>
<div>



<div class="slide">
  <h1>Text::Unidecode</h1>

Russian: Good-bye
<pre style="margin-left: 100px">
unidecode("–î–æ —Å–≤–∏–¥–∞–Ω–∏—è")
  => Do svidaniia
</pre>

Arabic: Good morning ("Sabah el kheer")
<pre style="margin-left: 100px">
unidecode("ÿµÿ®ÿßÿ≠ ÿßŸÑÿÆŸäÿ±")
  => SbH lkhyr 
</pre>

Thai: Tom Yum (the soup)
<pre style="margin-left: 100px">
unidecode("‡∏ï‡πâ‡∏°‡∏¢‡∏≥")
  => tmyam
</pre>

<br>
With PerlIO::via::Unidecode can do <pre>open(my $fh, "<:encoding(utf8):via(Unidecode)", $file)</pre>
</div>


<div class="slide">
  <h1>Annotate_unidecode</h1>

<pre style="font-size: 80%">
sub annotate_unidecode {
  my $val = shift;

  $val =~ s{ ( \P{ASCII} \P{Latin}* ) }
           {
             my $match = $1;
             "$match (" . unidecode($match) . ")"
           }egx;

  return $val;
}
</pre>

<br>
Quite useful for reading sparse mixed-script documents:

<pre style="font-size: 90%">
annotate_unidecode("Hello I am ËÆ∏Âã§ from Ê∑±Âú≥")'
  => Hello I am ËÆ∏Âã§ (Xu Qin) from Ê∑±Âú≥ (Shen Zhen)
</pre>

</div>

<div class="slide">
  <h1>Bi-Directional Writing</h1>
  <ul>
    <li>Perl has good bi-directional language support (such as Text::Bidi and Text::WrapI18N)</li>
    <li>In pre-hellenistic greek, it was common to write in alternating directions: Boustrophedon ("as the ox turns")</li>
  </ul>

  <br>

  <center><img src="img/boustrophedon.jpg"></center>
</div>



<div class="slide">
  <h1>Text::Boustrophedon</h1>

Most useless module ever, of course done with crazy regexp hacks<br>
  üòÅ üòÅ üòÅ

<br><br>

<pre style="font-size: 80%">
$ perl -CAS -MText::Boustrophedon \
       -E 'undef $/; say Text::Boustrophedon::greek(<>)' \
       < input.txt

Achilles glared at him and answered, "Fool, prate not 
       ∆®∆ön…ín…òvo…î on …òd n…í…î …ò…ø…ò úT .∆®∆ön…ín…òvo…î ∆öuod…í …òm o∆ö
between lions and men, wolves and lambs can never be of
     . ú«´uo…ø ú∆ö bn…í  ú«´uo…ø ú∆ö …ø…ò ú∆öo  ú…î…í…ò …ò∆ö…í ú ∆öud ,bnim …òno
Therefore there can be no understanding between you and
…òno lli∆ö ,∆®u n…ò…òw∆ö…òd ∆®∆ön…ín…òvo…î yn…í …òd …ò…ø…ò ú∆ö y…ím …øon ,…òm
or other shall fall and glut grim Ares with his life's 
                                                ."boold
</pre>
</div>





<div class="slide">
  <h1>The C curse</h1>

  <ul>
    <li>Historically perl strings have always tried to terminate strings with nul bytes like C</li>
    <li>However, perl also lets you store nul bytes in your strings so length is stored separately</li>
    <li>Interacting with unix things like path-names is more efficient if the string is known to be nul-terminated and to not contain nul-bytes</li>
    <li>Before perl 5.18, the regexp engine would sometimes read in the extra, optional nul byte which is normally OK except...</li>
  </ul>
</div>



<div class="slide">
  <h1>Virtual memory page permissions</h1>

  <ul>
    <li>It is common to use perl strings to point to memory not managed by perl, for example with memory mapped files</li>
    <li>However the OS can map the file anywhere in memory and the adjacent pages aren't guaranteed to be readable</li>
    <li>If the file mapped is an exact multiple of VM page size, and your OS has chosen a random address for the mapping, and you run certain regexps against the string, then &#128163; segfault &#128163;</li>
  </ul>
</div>



<div class="slide">
  <h1>Gap pages</h1>
  <ul>
    <li>To demonstrate this, nothing special is needed on OpenBSD: mappings are random and separated by gap pages</li>
    <li>If your OS allocates them in decreasing, adjacent addresses (ie linux without PaX patches), you can create a gap page yourself:</li>
  </ul>

<br>

  <pre>
use File::Map qw/map_file protect PROT_NONE/;

map_file(my $gap_page, "/dev/zero", "<", 0, 4096);
protect($gap_page, PROT_NONE);

map_file(my $string, "/dev/zero", "<", 0, 4096);

$string =~ /.$/; ## boom
  </pre>
</div>




<div class="slide">
  <h1>Re-Entrant Regexp Engine</h1>

  <ul>
    <li>Re-entrancy is when a function is invoked while already inside that function</li>
    <li>Different than thread-safe (compare threads vs unix signals)</li>
    <li>Before perl 5.14, the engine was not fully re-entrant:

<pre>
$ perl -e 'print "$]\n"'
5.008009
$ perl -e '"X" =~ m{(??{ "X" =~ m{} })}'
Segmentation fault
</pre>
    </li>
    <li>As we've seen, running code from inside the regexp engine is quite useful: Regexp::Grammars, Regexp::Assemble, Regexp::Exhaustive, our annotate_unidecode sub</li>
    <li>Real perl code needs to use regexps</li>
  </ul>
</div>





<div class="slide">
  <h1>Questions?</h1>
  <h2>This presentation:</h2>
  <ul>
    <li><a href="http://hoytech.github.io/regexp-presentation/">http://hoytech.github.io/regexp-presentation/</a></li>
  </ul>

  <br><br>

  <center>
  <a href="https://metacpan.org/module/Regexp::Debugger">Regexp::Debugger</a>
 &mdash;
  <a href="https://metacpan.org/module/Regexp::Grammars">Regexp::Grammars</a>
  <br>
  <a href="https://metacpan.org/module/Regexp::Assemble">Regexp::Assemble</a>
 &mdash;
  <a href="https://metacpan.org/module/Regexp::Exhaustive">Regexp::Exhaustive</a>
  <br>
  <a href="http://github.com/hoytech/Bio-Regexp/">Bio::Regexp</a>
 &mdash;
  <a href="https://metacpan.org/module/Text::Boustrophedon">Text::Boustrophedon</a>
  <br>
  <a href="https://metacpan.org/module/Text::Bidi">Text::Bidi</a>
 &mdash;
  <a href="https://metacpan.org/module/Text::WrapI18N">Text::WrapI18N</a>
  <br>
  <a href="https://metacpan.org/module/Text::Unidecode">Text::Unidecode</a>
 &mdash;
  <a href="https://metacpan.org/module/PerlIO::via::Unidecode">PerlIO::via::Unidecode</a>
  </center>
</div>


</div>
</body>
</html>
